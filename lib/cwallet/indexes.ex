defmodule Cwallet.Indexes do
  @moduledoc """
  Module for generating indexes used by th Mnemonic module
  to generate a phrase from the wordlist

  The mnemonic must encode entropy in a multiple of 32 bits(4 bytes).
  with more entropy length the security is improved, but the sentence length increases.
  We refer to initial entropy length as ENT.
  The allowed size of entropy(ENT) is 128-256 bits(16-32 bytes).

  First an initial entropy of ENT is generated.
  A checksum(C) is generated by taking the first ENT / 32 (ie. ENT=128 then 4 bits) bits of its SHA256 hash.
  This checksum is appended to end of the initial entropy.
  Next, these concatenated bits are split into group of 11 bits,
  each encoding a number from 0-2047, serving as index into a wordlist.
  Finally, we convert these numbers into words and use the joined words as a mnemonic sentence.

  The following table describes the relation between the initial entropy length (ENT),
  the checksum length (CS) and the length of the generated mnemonic sentence (MS) in words.

  ## Example
      CS = ENT / 32
      MS = (ENT + CS) / 11
      |  ENT  | CS | ENT+CS |  MS  |
      +-------+----+--------+------+
      |  128  |  4 |   132  |  12  |
      |  160  |  5 |   165  |  15  |
      |  192  |  6 |   198  |  18  |
      |  224  |  7 |   231  |  21  |
      |  256  |  8 |   264  |  24  |
  """

  alias Cwallet.Bits, as: Bits
  # 128 bits in bytes
  @entropy_byte_size 16

  @doc """
  Generates random numbers(indexes) using entropy for guaranteed randomness
  ## Examples
      iex> Indexes.generate_indexes()
      [674, 1135, 630, 1012, 624, 1428, 481, 1666, 693, 534, 1933, 628]
  """
  @spec generate_indexes() :: List.t()
  def generate_indexes do
    entropy = generate_entropy(@entropy_byte_size)
    checksum = generate_checksum(entropy, @entropy_byte_size)

    entropy
    |> Bits.to_binary_list()
    |> Enum.join()
    |> Kernel.<>(checksum)
    |> Bits.split_into_groups()
    |> Bits.parse_binary_list()
  end

  defp generate_entropy(entropy_byte_size) do
    :crypto.strong_rand_bytes(entropy_byte_size)
  end

  defp generate_checksum(entropy, entropy_byte_size) do
    entropy_bit_size = entropy_byte_size * 8
    checksum_length = trunc(entropy_bit_size / 32)

    # Take the first 4 bits of entropy
    :sha256
    |> :crypto.hash(entropy)
    |> Bits.to_binary_list()
    |> Enum.join()
    |> String.slice(0..(checksum_length - 1))
  end
end
